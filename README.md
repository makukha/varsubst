# varsubst
> Bash style variable substitution in C.

# Features

* Rich syntax compatible with [Docker Compose](https://docs.docker.com/reference/compose-file/interpolation/)
* [Nested expressions](#nested-expressions)
* [Minimalistic API](#api-reference)
* Thread-safe (not tested)
* [PEG grammar] () with parser generated by [PackCC](https://github.com/arithy/packcc)

# Syntax

Interpolation syntax matches [Docker Compose interpolation](https://docs.docker.com/reference/compose-file/interpolation/).

With variable `VAR` set to string `value`:

* [Direct substitution](#direct-substitution)
  * `${VAR}` or `$VAR` — results in `value`
* [Escape dollar sign](#escape-dollar-sign)
  * `$$` — results in `$`
  * `$$VAR` — results in `$VAR`
* [Default value](#default-value)
  * `${VAR:-default}` — results in `value` if `VAR` is set and non-empty, otherwise `default`
  * `${VAR-default}` — results in `value` if `VAR` is set (maybe empty), otherwise `default`
* [Required value](#required-value)
  * `${VAR:?error}` — results in `value` if `VAR` is set and non-empty, otherwise return error
  * `${VAR?error}` — results in `value` if `VAR` is set (maybe empty), otherwise return error
* [Alternative value](#alternative-value)
  * `${VAR:+repl}` — results in `repl` if `VAR` is set and non-empty, otherwise empty string
  * `${VAR+repl}` — results in `repl` if `VAR` is set (maybe empty), otherwise empty string
* [Nested expressions](#nested-expressions), or iterative evaluation
  * `${VAR:-${VAR2}}` — results in value of `VAR2` if `VAR` is not set or empty
  * `${VAR${VAR2}}` — results in value of `VAR3` if `VAR2` is set to string `3`
  * Iterative evaluation must be enabled explicitly, see [complete example](#complete-example).

## Variable names

Variable name can be any combination of upper- and lowercase letters, digits, and underscore characters, i.e. matching regular expression `[_a-zA-Z0-9]+`. For example, `${-}` and `${}` both raise invalid syntax error.


# Installation

> TODO


# API Reference

```c++
#include <varsubst.h>
```

```c++
void *varsubst(
    const char *input, // subst template string
    int varc,          // number of variables
    const char **vkey, // ptr to array of variable names
    const char **vval, // ptr to array of variable values
    Varsubst *res,     // subst params and result
);

typedef struct Varsubst {
    // params
    char depth;     // max subst iter count; 1 (default) if set to 0
    char copyplain; // copy input to result buffer even if no subst made; default 0
    size_t maxsize; // max length of subst result string; unlim if set to 0
    // customizations
    void *buffer;   // custom result string buffer; can be NULL
    // result
    char *input;    // pointer to input string
    char *result;   // result string; points to input if plain=1 and copyplain=0
    char error;     // see error/success flags
    char *mvkey;    // first missing variable name; normally NULL
    char *mverr;    // missing variable error; normally NULL
    char *mvtyp;    // missing type; normally 0
    // details
    char plain;     // 1 = template has no subst vars; 0 = some vars substituted
    char truncated; // 1 = result string was truncated, 0 = result is full
    char icnt;      // count of subst iterations actually performed
    
} Varsubst;

void varsubst_init(Varsubst *subst); // set zero defaults
void varsubst_free(Varsubst *subst); // free memory allocated by varsubst
```

## Error/success flags

* `VARSUBST_SUCCESS == 0` — success
* `VARSUBST_INVALID_SYNTAX != 0` — invalid template string syntax
* `VARSUBST_MISSING_VARIABLE != 0` — template string raises [required variable](#required-variable) error
* `VARSUBST_MEMORY_ERROR != 0` — out of memory

## Required variable missing type

* `VARSUBST_UNSET != 0` — variable name is not provided
* `VARSUBST_EMPTY != 0` — variable name is provided, but the value is an empty string
* `VARSUBST_MIGGING_STR(typ)` — macro for textual representation of missing types above: `"unset"` or `"empty"`

## Defaults

* `VARSUBST_DEFAULT_DEPTH = 1` — default nested expressions depth


# Usage

## Complete example

```c++
// hello.c

#include <stdio.h>
#include <stdlib.h>
#include <varsubst.h>

int main(int argc, char *argv) {
    Varsubst subst;
    varsubst_init(&subst);
    
    const char *keys[] = {"X", "Y", "Z"};
    const char *vals[] = {"v1", "v2", ""};
    
    subst.depth = 2;  // enable nested evaluation
    varsubst("$X-${Y}-$${${Z}Z}", 3, keys, vals, &subst);
    
    if (!subst.error) {
        puts(subst->result);
    }
    else if (subst.error == VARSUBST_INVALID_SYNTAX) {
        printf("Invalid template syntax: %s\n", subst.input);
    }
    else if (subst.error == VARSUBST_MEMORY_ERROR) {
        puts("Not enough memory");
    }
    else if (subst.error == VARSUBST_MISSING_VARIABLE) {
        printf("Variable '%s' is %s: %s\n", subst.mvkey,
            VARSUBST_MISSING_STR(subst.mvtyp), subst.mverr);
    }
    else {
        printf("Unsupported error code: %d", subst.error);
    }
    
    varsubst_free(&subst);
    exit(subst.error ? EXIT_FAILURE : EXIT_SUCCESS);
}
```

```shell
$ hello
v1-v2-
```

## Direct substitution

Simple variable substitution expression has two forms:

* `$VAR` — plain
* `${VAR}` — braced

```c++
// code fragment
const char *k[] = {"NAME", "VER"};
const char *v[] = {"hello", "0.1.0"};
varsubst("'$NAME --version': prints '${NAME} ${VER}'", 2, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
'hello --version': prints 'hello 0.1.0'
```

## Escape dollar sign

Double dollar sign `$$` evaluates to `$`.

```c++
// code fragment
const char *k = "BASE";
const char *v = "debian";
varsubst("image: ${BASE}:$${VERSION}", 1, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
image: debian:${VERSION}
```

## Default value

Default value is substituted when variable is [missing](#missing-variable-semantics):
* `default` when `VAR` is not set or empty: `${VAR:-default}`
* `default` when `VAR` is not set: `${VAR-default}`

```c++
// code fragment
const char *k[] = {"ORG", "APP"};
const char *v[] = {"myorg", ""};
varsubst("image: ${ORG}/${APP-base}:${TAG:-latest}", 2, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
image: myorg/base:latest
```

## Required value

Error with message `error` is raised when variable is [missing](#missing-variable-semantics):
* when `VAR` is not set or empty: `${VAR:?error}`
* when `VAR` is not set: `${VAR-error}`

```c++
// code fragment
const char *k[] = {"SUFFIX", "PATH"};
const char *v[] = {"", ""};
varsubst("sed -i'${SUFFIX-required}' \"${PATH:-empty}\"", 2, k, v, &subst);
if (subst.error == VARSUBST_MISSING_VARIABLE) {
    printf("Variable '%s' error: %s\n", subst->mvkey, subst->mverr);
}
```

```shell
$ hello
Variable 'PATH' error: empty
```

## Alternative value

Return replacement value `repl` when variable is NOT [missing](#missing-variable-semantics):
* `repl` when `VAR` is set and not empty: `${VAR:+repl}`
* `repl` when `VAR` is set (but may be empty): `${VAR+repl}`

```c++
// code fragment
const char *k[] = {"ORG", "IMG", "DESC"};
const char *v[] = {"", "debian", ""};
varsubst("{image: ${ORG}${ORG:+/}${IMG}${DESC+, desc: }${DESC}}", 3, k, v, &subst);
puts(subst->result);
```

```shell
$ hello
{image: debian, desc: }
```

## Nested expressions

Single evaluation of input string can lead to result that still contains variable substitution expressions. Theses expressions can come by different ways:
1. Template string contains nested expression: `${VAR:-${DEFAULT}}`
2. Variable value contains expression: `${VAR}`, where `VAR` contains `${DEFAULT}`

Iterative evaluation handles both cases. It is off by default, but can be easily turned on by setting `depth` (the maximum number of iterations) greater than 1. Whatever is the depth, iterative evaluation stops when the result string did not change compared to previous run.


Return replacement value `repl` when variable is NOT [missing](#missing-variable-semantics):
* `repl` when `VAR` is set and not empty: `${VAR:+repl}`
* `repl` when `VAR` is set (but may be empty): `${VAR+repl}`

```c++
// code fragment
const char *k[] = {"VAR1", "VAR2", "DEFAULT"};
const char *v[] = {"", "${DEFAULT}", "42"};
subst.depth = 3;
varsubst("VAR1=${VAR1:-$DEFAULT}, VAR2=${VAR2}", 3, k, v, &subst);
printf("%s (in %d iterations)", subst.result, subst.icnt);
```

```shell
$ hello
VAR1=42, VAR2=42
```

> [!WARNING]
> It is not recommended to set the depth greater than 2 or 3 because specially chosen template string and variable value can lead to out-of-memory error because of exponential expansion:
> ```c++
> // don't run this code
> char *k = "V";
> char *v = "$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V";
> Varsubst subst;
> varsubst_init(&subst);
> subst.depth = 6;
> varsubst(v, 1, k, v, &subst);  // result expands to 64 GiB
> ```

# Side notes

## Missing variable semantics

In supported [syntax](#syntax),
* ***Default*** expressions evaluate to `default` string if `VAR` is *missing*
* ***Required*** expressions raise `error` if `VAR` is *missing*
* ***Alternative*** expressions' variable values are replaced with `repl` if `VAR` is not *missing*

*Missing* falls under one of two definitions:

* *Missing* = ***"unset or empty"*** — `":"` suffix in `${VAR:-x}`, `${VAR:?x}`, `${VAR:+x}`
* *Missing* = ***"unset"*** — `""` suffix in `${VAR-x}`, `${VAR?x}`, `${VAR+x}`


# Performance

> TODO


# Contributing

> TODO

## Testing

> TODO


# Security

> TODO


# License

MIT license.


# Acknowledgements

My deepest gratitude goes to authors of projects that `varsubst` relies on:

* [PackCC](https://github.com/arithy/packcc) parser generator, for easily manageable substitution syntax.
* [Task](https://taskfile.dev) task runner, that is my interface to dev tasks for a long time.
* [Meson](https://mesonbuild.com) build system, for building the code.
* [Conan](https://conan.io) package manager, for publishing results.
