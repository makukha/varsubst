# vsub

> Bash-style variable substitution C library and tool.

# Features

* Rich syntax compatible with [Docker Compose](https://docs.docker.com/reference/compose-file/interpolation/)
* [Nested expressions](#nested-expressions)
* [Minimalistic API](#api-reference)
* Thread-safe (not tested)
* [PEG grammar] () with parser generated by [PackCC](https://github.com/arithy/packcc)

# Syntax

## Docker Compose v2.4.3+ (latest)

Interpolation syntax matches [Docker Compose interpolation](https://docs.docker.com/reference/compose-file/interpolation/).

With variable `VAR` set to string `value`:

* [Direct substitution](#direct-substitution)
    * `${VAR}` or `$VAR` — results in `value`
* [Escape dollar sign](#escape-dollar-sign)
    * `$$` — results in `$`
    * `$$VAR` — results in `$VAR`
* [Default value](#default-value)
    * `${VAR:-default}` — results in `value` if `VAR` is set and non-empty, otherwise `default`
    * `${VAR-default}` — results in `value` if `VAR` is set (maybe empty), otherwise `default`
* [Required value](#required-value)
    * `${VAR:?error}` — results in `value` if `VAR` is set and non-empty, otherwise return error
    * `${VAR?error}` — results in `value` if `VAR` is set (maybe empty), otherwise return error
* [Alternative value](#alternative-value)
    * `${VAR:+repl}` — results in `repl` if `VAR` is set and non-empty, otherwise empty string
    * `${VAR+repl}` — results in `repl` if `VAR` is set (maybe empty), otherwise empty string
* [Nested expressions](#nested-expressions), or iterative evaluation
    * `${VAR:-${VAR2}}` — results in value of `VAR2` if `VAR` is not set or empty
    * `${VAR${VAR2}}` — results in value of `VAR3` if `VAR2` is set to string `3`
    * Iterative evaluation must be enabled explicitly, see [complete example](#complete-example).

## Variable names

Variable name can be any combination of upper- and lowercase letters, digits, and underscore characters that does not start with number, i.e. matching regular expression `[_a-zA-Z][_a-zA-Z0-9]*`. For example, `${-}` and `${}` both raise invalid syntax error.


# Installation

> TODO


# API Reference

```c++
#include <vsub.h>
```

```c++
void *vsub(
    const char *input, // subst template string
    int varc,          // number of variables
    const char **vkey, // ptr to array of variable names
    const char **vval, // ptr to array of variable values
    Vsub *res,     // subst params and result
);

typedef struct Vsub {
    // params
    int syntax;     // syntax dialect, one of VSUB_SX_*; 0 by default
    char depth;     // max subst iter count; 1 (default) if set to 0
    char copyplain; // copy input to result buffer even if no subst made; default 0
    size_t maxsize; // max length of subst result string; unlim if set to 0
    // customizations
    void *buffer;   // custom result string buffer; can be NULL
    // result
    char *input;    // pointer to input string
    char *result;   // result string; points to input if plain=1 and copyplain=0
    char error;     // see error/success flags
    char *mvkey;    // first missing variable name; normally NULL
    char *mverr;    // missing variable error; normally NULL
    char *mvtyp;    // missing type, one of VSUB_MV_*; normally 0
    // details
    char plain;     // 1 = template has no subst vars; 0 = some vars substituted
    char truncated; // 1 = result string was truncated, 0 = result is full
    char icnt;      // count of subst iterations actually performed
    
} Vsub;

void vsub_init(Vsub *subst); // set zero defaults
void vsub_free(Vsub *subst); // free memory allocated by vsub

// constants
const int VSUB_SXS_LIST[];                 // array of syntax codes, see VSUB_SX_*
const size_t VSUB_SXS_COUNT;               // size of VSUB_SXS_LIST
const char* vsub_syntax_short_str(int sx); // short str for VSUB_SX_* or NULL
const char* vsub_syntax_long_str(int sx);  // long str for VSUB_SX_* or NULL
const char* vsub_missing_str(char mv);     // string for VSUB_MV_* or NULL
```

## Syntax dialects

* `VARSUB_SX_UNDEFINED == 0` — syntax is undefined
* `VARSUB_SX_DC243` — Docker Compose v2.4.3+ (latest)
* See also `varsub_syntax_short_str(int)` and `varsub_syntax_long_str(int)`


## Error/success flags

* `VARSUBST_SUCCESS == 0` — success
* `VARSUBST_INVALID_SYNTAX` — invalid template string syntax
* `VARSUBST_MISSING_VARIABLE` — template string raises [required variable](#required-variable) error
* `VARSUBST_MEMORY_ERROR` — out of memory

## Required variable missing type

* `VARSUBST_MV_VALID == 0` — variable is not [missing](#missing-variable-semantics)
* `VARSUBST_MV_UNSET` — variable name is not provided
* `VARSUBST_MV_EMPTY` — variable name is provided, but the value is an empty string
* `VARSUBST_MV_TO_STR(n)` — macro for string representation of missing type: `"valid"`, `"unset"`, `"empty"`, or `""`, if code is unsupported

## Defaults

* `VARSUBST_DEFAULT_DEPTH = 1` — default nested expressions depth


# Usage

## Complete example

```c++
// hello.c

#include <stdio.h>
#include <stdlib.h>
#include <varsubst.h>

int main(int argc, char *argv) {
    Varsubst subst;
    varsubst_init(&subst);
    
    const char *keys[] = {"X", "Y", "Z"};
    const char *vals[] = {"v1", "v2", ""};
    
    subst.depth = 2;  // enable nested evaluation
    varsubst("$X-${Y}-$${${Z}Z}", 3, keys, vals, &subst);
    
    if (!subst.error) {
        puts(subst->result);
    }
    else if (subst.error == VARSUBST_INVALID_SYNTAX) {
        printf("Invalid template syntax: %s\n", subst.input);
    }
    else if (subst.error == VARSUBST_MEMORY_ERROR) {
        puts("Not enough memory");
    }
    else if (subst.error == VARSUBST_MISSING_VARIABLE) {
        printf("Variable '%s' is %s: %s\n", subst.mvkey,
            VARSUBST_MISSING_STR(subst.mvtyp), subst.mverr);
    }
    else {
        printf("Unsupported error code: %d", subst.error);
    }
    
    varsubst_free(&subst);
    exit(subst.error ? EXIT_FAILURE : EXIT_SUCCESS);
}
```

```shell
$ hello
v1-v2-
```

## Direct substitution

Simple variable substitution expression has two forms:

* `$VAR` — plain
* `${VAR}` — braced

```c++
// code fragment
const char *k[] = {"NAME", "VER"};
const char *v[] = {"hello", "0.1.0"};
varsubst("'$NAME --version': prints '${NAME} ${VER}'", 2, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
'hello --version': prints 'hello 0.1.0'
```

## Escape dollar sign

Double dollar sign `$$` evaluates to `$`.

```c++
// code fragment
const char *k = "BASE";
const char *v = "debian";
varsubst("image: ${BASE}:$${VERSION}", 1, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
image: debian:${VERSION}
```

## Default value

Default value is substituted when variable is [missing](#missing-variable-semantics):
* `default` when `VAR` is not set or empty: `${VAR:-default}`
* `default` when `VAR` is not set: `${VAR-default}`

```c++
// code fragment
const char *k[] = {"ORG", "APP"};
const char *v[] = {"myorg", ""};
varsubst("image: ${ORG}/${APP-base}:${TAG:-latest}", 2, k, v, &subst);
puts(subst.result);
```

```shell
$ hello
image: myorg/base:latest
```

## Required value

Error with message `error` is raised when variable is [missing](#missing-variable-semantics):
* when `VAR` is not set or empty: `${VAR:?error}`
* when `VAR` is not set: `${VAR-error}`

```c++
// code fragment
const char *k[] = {"SUFFIX", "PATH"};
const char *v[] = {"", ""};
varsubst("sed -i'${SUFFIX-required}' \"${PATH:-empty}\"", 2, k, v, &subst);
if (subst.error == VARSUBST_MISSING_VARIABLE) {
    printf("Variable '%s' error: %s\n", subst->mvkey, subst->mverr);
}
```

```shell
$ hello
Variable 'PATH' error: empty
```

## Alternative value

Return replacement value `repl` when variable is NOT [missing](#missing-variable-semantics):
* `repl` when `VAR` is set and not empty: `${VAR:+repl}`
* `repl` when `VAR` is set (but may be empty): `${VAR+repl}`

```c++
// code fragment
const char *k[] = {"ORG", "IMG", "DESC"};
const char *v[] = {"", "debian", ""};
varsubst("{image: ${ORG}${ORG:+/}${IMG}${DESC+, desc: }${DESC}}", 3, k, v, &subst);
puts(subst->result);
```

```shell
$ hello
{image: debian, desc: }
```

## Nested expressions

Single evaluation of input string can lead to result that still contains variable substitution expressions. Theses expressions can come by different ways:
1. Template string contains nested expression: `${VAR:-${DEFAULT}}`
2. Variable value contains expression: `${VAR}`, where `VAR` contains `${DEFAULT}`

Iterative evaluation handles both cases. It is off by default, but can be easily turned on by setting `depth` (the maximum number of iterations) greater than 1. Whatever is the depth, iterative evaluation stops when the result string did not change compared to previous run.


Return replacement value `repl` when variable is NOT [missing](#missing-variable-semantics):
* `repl` when `VAR` is set and not empty: `${VAR:+repl}`
* `repl` when `VAR` is set (but may be empty): `${VAR+repl}`

```c++
// code fragment
const char *k[] = {"VAR1", "VAR2", "DEFAULT"};
const char *v[] = {"", "${DEFAULT}", "42"};
subst.depth = 3;
varsubst("VAR1=${VAR1:-$DEFAULT}, VAR2=${VAR2}", 3, k, v, &subst);
printf("%s (in %d iterations)", subst.result, subst.icnt);
```

```shell
$ hello
VAR1=42, VAR2=42
```

> [!WARNING]
> It is not recommended to set the depth greater than 2 or 3 because specially chosen template string and variable value can lead to out-of-memory error because of exponential expansion:
> ```c++
> // don't run this code
> char *k = "V";
> char *v = "$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V$V";
> Varsubst subst;
> varsubst_init(&subst);
> subst.depth = 6;
> varsubst(v, 1, k, v, &subst);  // result expands to 64 GiB
> ```

# Side notes

## Missing variable semantics

In supported [syntax](#syntax),
* ***Default*** expressions evaluate to `default` string if `VAR` is *missing*
* ***Required*** expressions raise `error` if `VAR` is *missing*
* ***Alternative*** expressions' variable values are replaced with `repl` if `VAR` is not *missing*

*Missing* falls under one of two definitions:

* *Missing* = ***"unset or empty"*** — `":"` suffix in `${VAR:-x}`, `${VAR:?x}`, `${VAR:+x}`
* *Missing* = ***"unset"*** — `""` suffix in `${VAR-x}`, `${VAR?x}`, `${VAR+x}`


# Performance

> TODO


# Contributing

Install [Task](https://taskfile.dev) and Docker.

```shell
$ task build
$ task test
```
```shell
$ task rebuild
$ task clean build
$ task clean
```

## Testing

> TODO


# Security

> TODO


# License

MIT license.


# Acknowledgements

My deepest gratitude goes to authors of

* [PackCC](https://github.com/arithy/packcc) PEG parser generator
* [Task](https://taskfile.dev) runner, that is my interface to dev tasks for a long time
* [Meson](https://mesonbuild.com) super easy build system


# References

* Docker Compose [interpolation docs](https://docs.docker.com/reference/compose-file/interpolation/)
* Docker Compose [template substitution implementation](https://github.com/compose-spec/compose-go/blob/main/template/template.go)
* Dockerfile [environment substitution docs](https://docs.docker.com/reference/dockerfile/#environment-replacement)
